from .occ_impl.exporters.svg import exportSVG as exportSVG, getSVG as getSVG
from .occ_impl.geom import Location as Location, Plane as Plane, Vector as Vector
from .occ_impl.shapes import Compound as Compound, Edge as Edge, Face as Face, Shape as Shape, Solid as Solid, Wire as Wire, wiresToFaces as wiresToFaces
from .selectors import Selector as Selector, StringSyntaxSelector as StringSyntaxSelector
from .sketch import Sketch as Sketch
from .utils import deprecate as deprecate, deprecate_kwarg_name as deprecate_kwarg_name
from typing import Any, Callable, Dict, Iterable, List, Optional, Sequence, Tuple, TypeVar, Union, overload
from typing_extensions import Literal

CQObject = Union[Vector, Location, Shape, Sketch]
VectorLike = Union[Tuple[float, float], Tuple[float, float, float], Vector]
CombineMode: Any
TOL: float
T = TypeVar('T', bound='Workplane')

class CQContext:
    pendingWires: List[Wire]
    pendingEdges: List[Edge]
    firstPoint: Optional[Vector]
    tolerance: float
    tags: Dict[str, 'Workplane']
    def __init__(self) -> None: ...
    def popPendingEdges(self, errorOnEmpty: bool = ...) -> List[Edge]: ...
    def popPendingWires(self, errorOnEmpty: bool = ...) -> List[Wire]: ...

class Workplane:
    objects: List[CQObject]
    ctx: CQContext
    parent: Optional['Workplane']
    plane: Plane
    @overload
    def __init__(self, obj: CQObject) -> None: ...
    @overload
    def __init__(self, inPlane: Union[Plane, str] = ..., origin: VectorLike = ..., obj: Optional[CQObject] = ...) -> None: ...
    def tag(self, name: str) -> T: ...
    @overload
    def split(self, keepTop: bool = ..., keepBottom: bool = ...) -> T: ...
    @overload
    def split(self, splitter: Union[T, Shape]) -> T: ...
    def combineSolids(self, otherCQToCombine: Optional['Workplane'] = ...) -> Workplane: ...
    def all(self) -> List[T]: ...
    def size(self) -> int: ...
    def vals(self) -> List[CQObject]: ...
    @overload
    def add(self, obj: Workplane) -> T: ...
    @overload
    def add(self, obj: CQObject) -> T: ...
    @overload
    def add(self, obj: Iterable[CQObject]) -> T: ...
    def val(self) -> CQObject: ...
    def toOCC(self) -> Any: ...
    def workplane(self, offset: float = ..., invert: bool = ..., centerOption: Literal['CenterOfMass', 'ProjectedOrigin', 'CenterOfBoundBox'] = ..., origin: Optional[VectorLike] = ...) -> T: ...
    def copyWorkplane(self, obj: T) -> T: ...
    def workplaneFromTagged(self, name: str) -> Workplane: ...
    def first(self) -> T: ...
    def item(self, i: int) -> T: ...
    def last(self) -> T: ...
    def end(self, n: int = ...) -> Workplane: ...
    def findSolid(self, searchStack: bool = ..., searchParents: bool = ...) -> Union[Solid, Compound]: ...
    def findFace(self, searchStack: bool = ..., searchParents: bool = ...) -> Face: ...
    def vertices(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def faces(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def edges(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def wires(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def solids(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def shells(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def compounds(self, selector: Optional[Union[Selector, str]] = ..., tag: Optional[str] = ...) -> T: ...
    def toSvg(self, opts: Any = ...) -> str: ...
    def exportSvg(self, fileName: str) -> None: ...
    def rotateAboutCenter(self, axisEndPoint: VectorLike, angleDegrees: float) -> T: ...
    def rotate(self, axisStartPoint: VectorLike, axisEndPoint: VectorLike, angleDegrees: float) -> T: ...
    def mirror(self, mirrorPlane: Union[Literal['XY', 'YX', 'XZ', 'ZX', 'YZ', 'ZY'], VectorLike, Face, 'Workplane'] = ..., basePointVector: Optional[VectorLike] = ..., union: bool = ...) -> T: ...
    def translate(self, vec: VectorLike) -> T: ...
    def shell(self, thickness: float, kind: Literal['arc', 'intersection'] = ...) -> T: ...
    def fillet(self, radius: float) -> T: ...
    def chamfer(self, length: float, length2: Optional[float] = ...) -> T: ...
    def transformed(self, rotate: VectorLike = ..., offset: VectorLike = ...) -> T: ...
    def newObject(self, objlist: Iterable[CQObject]) -> T: ...
    def rarray(self, xSpacing: float, ySpacing: float, xCount: int, yCount: int, center: Union[bool, Tuple[bool, bool]] = ...) -> T: ...
    def polarArray(self, radius: float, startAngle: float, angle: float, count: int, fill: bool = ..., rotate: bool = ...) -> T: ...
    def pushPoints(self, pntList: Iterable[Union[VectorLike, Location]]) -> T: ...
    def center(self, x: float, y: float) -> T: ...
    def lineTo(self, x: float, y: float, forConstruction: bool = ...) -> T: ...
    def line(self, xDist: float, yDist: float, forConstruction: bool = ...) -> T: ...
    def vLine(self, distance: float, forConstruction: bool = ...) -> T: ...
    def hLine(self, distance: float, forConstruction: bool = ...) -> T: ...
    def vLineTo(self, yCoord: float, forConstruction: bool = ...) -> T: ...
    def hLineTo(self, xCoord: float, forConstruction: bool = ...) -> T: ...
    def polarLine(self, distance: float, angle: float, forConstruction: bool = ...) -> T: ...
    def polarLineTo(self, distance: float, angle: float, forConstruction: bool = ...) -> T: ...
    def moveTo(self, x: float = ..., y: float = ...) -> T: ...
    def move(self, xDist: float = ..., yDist: float = ...) -> T: ...
    def slot2D(self, length: float, diameter: float, angle: float = ...) -> T: ...
    def spline(self, listOfXYTuple: Iterable[VectorLike], tangents: Optional[Sequence[VectorLike]] = ..., periodic: bool = ..., parameters: Optional[Sequence[float]] = ..., scale: bool = ..., tol: Optional[float] = ..., forConstruction: bool = ..., includeCurrent: bool = ..., makeWire: bool = ...) -> T: ...
    def splineApprox(self, points: Iterable[VectorLike], tol: Optional[float] = ..., minDeg: int = ..., maxDeg: int = ..., smoothing: Optional[Tuple[float, float, float]] = ..., forConstruction: bool = ..., includeCurrent: bool = ..., makeWire: bool = ...) -> T: ...
    def parametricCurve(self, func: Callable[[float], VectorLike], N: int = ..., start: float = ..., stop: float = ..., tol: float = ..., minDeg: int = ..., maxDeg: int = ..., smoothing: Optional[Tuple[float, float, float]] = ..., makeWire: bool = ...) -> T: ...
    def parametricSurface(self, func: Callable[[float, float], VectorLike], N: int = ..., start: float = ..., stop: float = ..., tol: float = ..., minDeg: int = ..., maxDeg: int = ..., smoothing: Optional[Tuple[float, float, float]] = ...) -> T: ...
    def ellipseArc(self, x_radius: float, y_radius: float, angle1: float = ..., angle2: float = ..., rotation_angle: float = ..., sense: Literal[-1, 1] = ..., forConstruction: bool = ..., startAtCurrent: bool = ..., makeWire: bool = ...) -> T: ...
    def threePointArc(self, point1: VectorLike, point2: VectorLike, forConstruction: bool = ...) -> T: ...
    def sagittaArc(self, endPoint: VectorLike, sag: float, forConstruction: bool = ...) -> T: ...
    def radiusArc(self, endPoint: VectorLike, radius: float, forConstruction: bool = ...) -> T: ...
    def tangentArcPoint(self, endpoint: VectorLike, forConstruction: bool = ..., relative: bool = ...) -> T: ...
    def mirrorY(self) -> T: ...
    def mirrorX(self) -> T: ...
    def consolidateWires(self) -> T: ...
    def wire(self, forConstruction: bool = ...) -> T: ...
    def each(self, callback: Callable[[CQObject], Shape], useLocalCoordinates: bool = ..., combine: CombineMode = ..., clean: bool = ...) -> T: ...
    def eachpoint(self, callback: Callable[[Location], Shape], useLocalCoordinates: bool = ..., combine: CombineMode = ..., clean: bool = ...) -> T: ...
    def rect(self, xLen: float, yLen: float, centered: Union[bool, Tuple[bool, bool]] = ..., forConstruction: bool = ...) -> T: ...
    def circle(self, radius: float, forConstruction: bool = ...) -> T: ...
    def ellipse(self, x_radius: float, y_radius: float, rotation_angle: float = ..., forConstruction: bool = ...) -> T: ...
    def polygon(self, nSides: int, diameter: float, forConstruction: bool = ..., circumscribed: bool = ...) -> T: ...
    def polyline(self, listOfXYTuple: Sequence[VectorLike], forConstruction: bool = ..., includeCurrent: bool = ...) -> T: ...
    def close(self) -> T: ...
    def largestDimension(self) -> float: ...
    def cutEach(self, fcn: Callable[[Location], Shape], useLocalCoords: bool = ..., clean: bool = ...) -> T: ...
    def cboreHole(self, diameter: float, cboreDiameter: float, cboreDepth: float, depth: Optional[float] = ..., clean: bool = ...) -> T: ...
    def cskHole(self, diameter: float, cskDiameter: float, cskAngle: float, depth: Optional[float] = ..., clean: bool = ...) -> T: ...
    def hole(self, diameter: float, depth: Optional[float] = ..., clean: bool = ...) -> T: ...
    def twistExtrude(self, distance: float, angleDegrees: float, combine: CombineMode = ..., clean: bool = ...) -> T: ...
    def extrude(self, until: Union[float, Literal['next', 'last'], Face], combine: CombineMode = ..., clean: bool = ..., both: bool = ..., taper: Optional[float] = ...) -> T: ...
    def revolve(self, angleDegrees: float = ..., axisStart: Optional[VectorLike] = ..., axisEnd: Optional[VectorLike] = ..., combine: CombineMode = ..., clean: bool = ...) -> T: ...
    def sweep(self, path: Union['Workplane', Wire, Edge], multisection: bool = ..., sweepAlongWires: Optional[bool] = ..., makeSolid: bool = ..., isFrenet: bool = ..., combine: CombineMode = ..., clean: bool = ..., transition: Literal['right', 'round', 'transformed'] = ..., normal: Optional[VectorLike] = ..., auxSpine: Optional['Workplane'] = ...) -> T: ...
    def combine(self, clean: bool = ..., glue: bool = ..., tol: Optional[float] = ...) -> T: ...
    def union(self, toUnion: Optional[Union['Workplane', Solid, Compound]] = ..., clean: bool = ..., glue: bool = ..., tol: Optional[float] = ...) -> T: ...
    def __or__(self, toUnion: Union['Workplane', Solid, Compound]) -> T: ...
    def __add__(self, toUnion: Union['Workplane', Solid, Compound]) -> T: ...
    def cut(self, toCut: Union['Workplane', Solid, Compound], clean: bool = ...) -> T: ...
    def __sub__(self, toUnion: Union['Workplane', Solid, Compound]) -> T: ...
    def intersect(self, toIntersect: Union['Workplane', Solid, Compound], clean: bool = ...) -> T: ...
    def __and__(self, toUnion: Union['Workplane', Solid, Compound]) -> T: ...
    def cutBlind(self, until: Union[float, Literal['next', 'last'], Face], clean: bool = ..., taper: Optional[float] = ...) -> T: ...
    def cutThruAll(self, clean: bool = ..., taper: float = ...) -> T: ...
    def loft(self, ruled: bool = ..., combine: CombineMode = ..., clean: bool = ...) -> T: ...
    def interpPlate(self, surf_edges: Union[Sequence[VectorLike], Sequence[Edge]], surf_pts: Sequence[VectorLike] = ..., thickness: float = ..., combine: bool = ..., clean: bool = ..., degree: int = ..., nbPtsOnCur: int = ..., nbIter: int = ..., anisotropy: bool = ..., tol2d: float = ..., tol3d: float = ..., tolAng: float = ..., tolCurv: float = ..., maxDeg: int = ..., maxSegments: int = ...) -> T: ...
    def box(self, length: float, width: float, height: float, centered: Union[bool, Tuple[bool, bool, bool]] = ..., combine: bool = ..., clean: bool = ...) -> T: ...
    def sphere(self, radius: float, direct: VectorLike = ..., angle1: float = ..., angle2: float = ..., angle3: float = ..., centered: Union[bool, Tuple[bool, bool, bool]] = ..., combine: bool = ..., clean: bool = ...) -> T: ...
    def cylinder(self, height: float, radius: float, direct: Vector = ..., angle: float = ..., centered: Union[bool, Tuple[bool, bool, bool]] = ..., combine: bool = ..., clean: bool = ...) -> T: ...
    def wedge(self, dx: float, dy: float, dz: float, xmin: float, zmin: float, xmax: float, zmax: float, pnt: VectorLike = ..., dir: VectorLike = ..., centered: Union[bool, Tuple[bool, bool, bool]] = ..., combine: bool = ..., clean: bool = ...) -> T: ...
    def clean(self) -> T: ...
    def text(self, txt: str, fontsize: float, distance: float, cut: bool = ..., combine: CombineMode = ..., clean: bool = ..., font: str = ..., fontPath: Optional[str] = ..., kind: Literal['regular', 'bold', 'italic'] = ..., halign: Literal['center', 'left', 'right'] = ..., valign: Literal['center', 'top', 'bottom'] = ...) -> T: ...
    def section(self, height: float = ...) -> T: ...
    def toPending(self) -> T: ...
    def offset2D(self, d: float, kind: Literal['arc', 'intersection', 'tangent'] = ..., forConstruction: bool = ...) -> T: ...
    def sketch(self) -> Sketch: ...
    def placeSketch(self, *sketches: Sketch) -> T: ...
CQ = Workplane
