from .geom import BoundBox as BoundBox, Location as Location, Matrix as Matrix, Plane as Plane, Vector as Vector
from OCP.BRepAlgoAPI import BRepAlgoAPI_BooleanOperation as BRepAlgoAPI_BooleanOperation
from OCP.Geom import Geom_Surface as Geom_Surface
from OCP.GeomAbs import GeomAbs_Shape as GeomAbs_Shape
from OCP.GeomFill import GeomFill_TrihedronLaw as GeomFill_TrihedronLaw
from OCP.IFSelect import IFSelect_ReturnStatus as IFSelect_ReturnStatus
from OCP.TopAbs import TopAbs_ShapeEnum as TopAbs_ShapeEnum
from OCP.TopoDS import TopoDS_CompSolid as TopoDS_CompSolid, TopoDS_Compound, TopoDS_Edge as TopoDS_Edge, TopoDS_Face, TopoDS_Shape, TopoDS_Shell as TopoDS_Shell, TopoDS_Solid as TopoDS_Solid, TopoDS_Vertex as TopoDS_Vertex, TopoDS_Wire as TopoDS_Wire
from OCP.gp import gp_Pln, gp_Pnt
from io import BytesIO
from typing import Any, Iterable, Iterator, List, Optional, Sequence, Tuple, TypeVar, Union, overload
from typing_extensions import Literal, Protocol as Protocol
from vtkmodules.vtkCommonDataModel import vtkPolyData as vtkPolyData

Real = Union[float, int]
TOLERANCE: float
DEG2RAD: Any
HASH_CODE_MAX: int
shape_LUT: Any
shape_properties_LUT: Any
inverse_shape_LUT: Any
downcast_LUT: Any
geom_LUT: Any
geom_LUT_FACE: Any
geom_LUT_EDGE: Any
Shapes: Any
Geoms: Any
VectorLike = Union[Vector, Tuple[float, float, float]]
T = TypeVar('T', bound='Shape')

def shapetype(obj: TopoDS_Shape) -> TopAbs_ShapeEnum: ...
def downcast(obj: TopoDS_Shape) -> TopoDS_Shape: ...
def fix(obj: TopoDS_Shape) -> TopoDS_Shape: ...

class Shape:
    wrapped: TopoDS_Shape
    forConstruction: bool
    label: str
    def __init__(self, obj: TopoDS_Shape) -> None: ...
    def clean(self) -> T: ...
    def fix(self) -> T: ...
    @classmethod
    def cast(cls, obj: TopoDS_Shape, forConstruction: bool = ...) -> Shape: ...
    def exportStl(self, fileName: str, tolerance: float = ..., angularTolerance: float = ...) -> bool: ...
    def exportStep(self, fileName: str) -> IFSelect_ReturnStatus: ...
    def exportBrep(self, f: Union[str, BytesIO]) -> bool: ...
    @classmethod
    def importBrep(cls, f: Union[str, BytesIO]) -> Shape: ...
    def geomType(self) -> Geoms: ...
    def hashCode(self) -> int: ...
    def isNull(self) -> bool: ...
    def isSame(self, other: Shape) -> bool: ...
    def isEqual(self, other: Shape) -> bool: ...
    def isValid(self) -> bool: ...
    def BoundingBox(self, tolerance: Optional[float] = ...) -> BoundBox: ...
    def mirror(self, mirrorPlane: Union[Literal['XY', 'YX', 'XZ', 'ZX', 'YZ', 'ZY'], VectorLike] = ..., basePointVector: VectorLike = ...) -> Shape: ...
    def Center(self) -> Vector: ...
    def CenterOfBoundBox(self, tolerance: Optional[float] = ...) -> Vector: ...
    @staticmethod
    def CombinedCenter(objects: Iterable['Shape']) -> Vector: ...
    @staticmethod
    def computeMass(obj: Shape) -> float: ...
    @staticmethod
    def centerOfMass(obj: Shape) -> Vector: ...
    @staticmethod
    def CombinedCenterOfBoundBox(objects: List['Shape']) -> Vector: ...
    def Closed(self) -> bool: ...
    def ShapeType(self) -> Shapes: ...
    def Vertices(self) -> List['Vertex']: ...
    def Edges(self) -> List['Edge']: ...
    def Compounds(self) -> List['Compound']: ...
    def Wires(self) -> List['Wire']: ...
    def Faces(self) -> List['Face']: ...
    def Shells(self) -> List['Shell']: ...
    def Solids(self) -> List['Solid']: ...
    def CompSolids(self) -> List['CompSolid']: ...
    def Area(self) -> float: ...
    def Volume(self) -> float: ...
    def rotate(self, startVector: Vector, endVector: Vector, angleDegrees: float) -> T: ...
    def translate(self, vector: Vector) -> T: ...
    def scale(self, factor: float) -> Shape: ...
    def copy(self) -> T: ...
    def transformShape(self, tMatrix: Matrix) -> Shape: ...
    def transformGeometry(self, tMatrix: Matrix) -> Shape: ...
    def location(self) -> Location: ...
    def locate(self, loc: Location) -> T: ...
    def located(self, loc: Location) -> T: ...
    def move(self, loc: Location) -> T: ...
    def moved(self, loc: Location) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def cut(self, *toCut: Shape) -> Shape: ...
    def fuse(self, *toFuse: Shape, glue: bool = ..., tol: Optional[float] = ...) -> Shape: ...
    def intersect(self, *toIntersect: Shape) -> Shape: ...
    def facesIntersectedByLine(self, point: VectorLike, axis: VectorLike, tol: float = ..., direction: Optional[Literal['AlongAxis', 'Opposite']] = ...): ...
    def split(self, *splitters: Shape) -> Shape: ...
    def mesh(self, tolerance: float, angularTolerance: float = ...): ...
    def tessellate(self, tolerance: float, angularTolerance: float = ...) -> Tuple[List[Vector], List[Tuple[int, int, int]]]: ...
    def toVtkPolyData(self, tolerance: float, angularTolerance: float = ..., normals: bool = ...) -> vtkPolyData: ...

class ShapeProtocol:
    @property
    def wrapped(self) -> TopoDS_Shape: ...
    def __init__(self, wrapped: TopoDS_Shape) -> None: ...
    def Faces(self) -> List['Face']: ...
    def geomType(self) -> Geoms: ...

class Vertex(Shape):
    wrapped: TopoDS_Vertex
    forConstruction: Any
    def __init__(self, obj: TopoDS_Shape, forConstruction: bool = ...) -> None: ...
    def toTuple(self) -> Tuple[float, float, float]: ...
    def Center(self) -> Vector: ...
    @classmethod
    def makeVertex(cls, x: float, y: float, z: float) -> Vertex: ...

class Mixin1DProtocol(ShapeProtocol):
    def paramAt(self, d: float) -> float: ...
    def positionAt(self, d: float, mode: Literal['length', 'parameter'] = ...) -> Vector: ...
    def locationAt(self, d: float, mode: Literal['length', 'parameter'] = ..., frame: Literal['frenet', 'corrected'] = ..., planar: bool = ...) -> Location: ...

class Mixin1D:
    def startPoint(self) -> Vector: ...
    def endPoint(self) -> Vector: ...
    def paramAt(self, d: float) -> float: ...
    def tangentAt(self, locationParam: float = ..., mode: Literal['length', 'parameter'] = ...) -> Vector: ...
    def normal(self) -> Vector: ...
    def Center(self) -> Vector: ...
    def Length(self) -> float: ...
    def radius(self) -> float: ...
    def IsClosed(self) -> bool: ...
    def positionAt(self, d: float, mode: Literal['length', 'parameter'] = ...) -> Vector: ...
    def positions(self, ds: Iterable[float], mode: Literal['length', 'parameter'] = ...) -> List[Vector]: ...
    def locationAt(self, d: float, mode: Literal['length', 'parameter'] = ..., frame: Literal['frenet', 'corrected'] = ..., planar: bool = ...) -> Location: ...
    def locations(self, ds: Iterable[float], mode: Literal['length', 'parameter'] = ..., frame: Literal['frenet', 'corrected'] = ..., planar: bool = ...) -> List[Location]: ...

class Edge(Shape, Mixin1D):
    wrapped: TopoDS_Edge
    def close(self) -> Union['Edge', 'Wire']: ...
    def arcCenter(self) -> Vector: ...
    @classmethod
    def makeCircle(cls, radius: float, pnt: VectorLike = ..., dir: VectorLike = ..., angle1: float = ..., angle2: float = ..., orientation: bool = ...) -> Edge: ...
    @classmethod
    def makeEllipse(cls, x_radius: float, y_radius: float, pnt: VectorLike = ..., dir: VectorLike = ..., xdir: VectorLike = ..., angle1: float = ..., angle2: float = ..., sense: Literal[-1, 1] = ...) -> Edge: ...
    @classmethod
    def makeSpline(cls, listOfVector: List[Vector], tangents: Optional[Sequence[Vector]] = ..., periodic: bool = ..., parameters: Optional[Sequence[float]] = ..., scale: bool = ..., tol: float = ...) -> Edge: ...
    @classmethod
    def makeSplineApprox(cls, listOfVector: List[Vector], tol: float = ..., smoothing: Optional[Tuple[float, float, float]] = ..., minDeg: int = ..., maxDeg: int = ...) -> Edge: ...
    @classmethod
    def makeThreePointArc(cls, v1: Vector, v2: Vector, v3: Vector) -> Edge: ...
    @classmethod
    def makeTangentArc(cls, v1: Vector, v2: Vector, v3: Vector) -> Edge: ...
    @classmethod
    def makeLine(cls, v1: Vector, v2: Vector) -> Edge: ...

class Wire(Shape, Mixin1D):
    wrapped: TopoDS_Wire
    def close(self) -> Wire: ...
    @classmethod
    def combine(cls, listOfWires: Iterable[Union['Wire', Edge]], tol: float = ...) -> List['Wire']: ...
    @classmethod
    def assembleEdges(cls, listOfEdges: Iterable[Edge]) -> Wire: ...
    @classmethod
    def makeCircle(cls, radius: float, center: Vector, normal: Vector) -> Wire: ...
    @classmethod
    def makeEllipse(cls, x_radius: float, y_radius: float, center: Vector, normal: Vector, xDir: Vector, angle1: float = ..., angle2: float = ..., rotation_angle: float = ..., closed: bool = ...) -> Wire: ...
    @classmethod
    def makePolygon(cls, listOfVertices: Iterable[Vector], forConstruction: bool = ...) -> Wire: ...
    @classmethod
    def makeHelix(cls, pitch: float, height: float, radius: float, center: Vector = ..., dir: Vector = ..., angle: float = ..., lefthand: bool = ...) -> Wire: ...
    def stitch(self, other: Wire) -> Wire: ...
    def offset2D(self, d: float, kind: Literal['arc', 'intersection', 'tangent'] = ...) -> List['Wire']: ...
    def fillet2D(self, radius: float, vertices: Iterable[Vertex]) -> Wire: ...
    def chamfer2D(self, d: float, vertices: Iterable[Vertex]) -> Wire: ...

class Face(Shape):
    wrapped: TopoDS_Face
    def normalAt(self, locationVector: Optional[Vector] = ...) -> Vector: ...
    def Center(self) -> Vector: ...
    def outerWire(self) -> Wire: ...
    def innerWires(self) -> List[Wire]: ...
    @classmethod
    def makeNSidedSurface(cls, edges: Iterable[Edge], points: Iterable[gp_Pnt], continuity: GeomAbs_Shape = ..., degree: int = ..., nbPtsOnCur: int = ..., nbIter: int = ..., anisotropy: bool = ..., tol2d: float = ..., tol3d: float = ..., tolAng: float = ..., tolCurv: float = ..., maxDeg: int = ..., maxSegments: int = ...) -> Face: ...
    @classmethod
    def makePlane(cls, length: Optional[float] = ..., width: Optional[float] = ..., basePnt: VectorLike = ..., dir: VectorLike = ...) -> Face: ...
    @overload
    @classmethod
    def makeRuledSurface(cls, edgeOrWire1: Edge, edgeOrWire2: Edge) -> Face: ...
    @overload
    @classmethod
    def makeRuledSurface(cls, edgeOrWire1: Wire, edgeOrWire2: Wire) -> Face: ...
    @classmethod
    def makeFromWires(cls, outerWire: Wire, innerWires: List[Wire] = ...) -> Face: ...
    @classmethod
    def makeSplineApprox(cls, points: List[List[Vector]], tol: float = ..., smoothing: Optional[Tuple[float, float, float]] = ..., minDeg: int = ..., maxDeg: int = ...) -> Face: ...
    def fillet2D(self, radius: float, vertices: Iterable[Vertex]) -> Face: ...
    def chamfer2D(self, d: float, vertices: Iterable[Vertex]) -> Face: ...
    def toPln(self) -> gp_Pln: ...

class Shell(Shape):
    wrapped: TopoDS_Shell
    @classmethod
    def makeShell(cls, listOfFaces: Iterable[Face]) -> Shell: ...
TS = TypeVar('TS', bound=ShapeProtocol)

class Mixin3D:
    def fillet(self, radius: float, edgeList: Iterable[Edge]) -> Any: ...
    def chamfer(self, length: float, length2: Optional[float], edgeList: Iterable[Edge]) -> Any: ...
    def shell(self, faceList: Optional[Iterable[Face]], thickness: float, tolerance: float = ..., kind: Literal['arc', 'intersection'] = ...) -> Any: ...
    def isInside(self, point: VectorLike, tolerance: float = ...) -> bool: ...

class Solid(Shape, Mixin3D):
    wrapped: TopoDS_Solid
    @classmethod
    def interpPlate(cls, surf_edges, surf_pts, thickness, degree: int = ..., nbPtsOnCur: int = ..., nbIter: int = ..., anisotropy: bool = ..., tol2d: float = ..., tol3d: float = ..., tolAng: float = ..., tolCurv: float = ..., maxDeg: int = ..., maxSegments: int = ...) -> Union['Solid', Face]: ...
    @staticmethod
    def isSolid(obj: Shape) -> bool: ...
    @classmethod
    def makeSolid(cls, shell: Shell) -> Solid: ...
    @classmethod
    def makeBox(cls, length: float, width: float, height: float, pnt: Vector = ..., dir: Vector = ...) -> Solid: ...
    @classmethod
    def makeCone(cls, radius1: float, radius2: float, height: float, pnt: Vector = ..., dir: Vector = ..., angleDegrees: float = ...) -> Solid: ...
    @classmethod
    def makeCylinder(cls, radius: float, height: float, pnt: Vector = ..., dir: Vector = ..., angleDegrees: float = ...) -> Solid: ...
    @classmethod
    def makeTorus(cls, radius1: float, radius2: float, pnt: Vector = ..., dir: Vector = ..., angleDegrees1: float = ..., angleDegrees2: float = ...) -> Solid: ...
    @classmethod
    def makeLoft(cls, listOfWire: List[Wire], ruled: bool = ...) -> Solid: ...
    @classmethod
    def makeWedge(cls, dx: float, dy: float, dz: float, xmin: float, zmin: float, xmax: float, zmax: float, pnt: Vector = ..., dir: Vector = ...) -> Solid: ...
    @classmethod
    def makeSphere(cls, radius: float, pnt: Vector = ..., dir: Vector = ..., angleDegrees1: float = ..., angleDegrees2: float = ..., angleDegrees3: float = ...) -> Shape: ...
    @classmethod
    def sweep_multi(cls, profiles: Iterable[Union[Wire, Face]], path: Union[Wire, Edge], makeSolid: bool = ..., isFrenet: bool = ..., mode: Union[Vector, Wire, Edge, None] = ...) -> Solid: ...

class CompSolid(Shape, Mixin3D):
    wrapped: TopoDS_CompSolid

class Compound(Shape, Mixin3D):
    wrapped: TopoDS_Compound
    def remove(self, shape: Shape): ...
    @classmethod
    def makeCompound(cls, listOfShapes: Iterable[Shape]) -> Compound: ...
    @classmethod
    def makeText(cls, text: str, size: float, height: float, font: str = ..., fontPath: Optional[str] = ..., kind: Literal['regular', 'bold', 'italic'] = ..., halign: Literal['center', 'left', 'right'] = ..., valign: Literal['center', 'top', 'bottom'] = ..., position: Plane = ...) -> Shape: ...
    def __iter__(self) -> Iterator[Shape]: ...
    def __bool__(self) -> bool: ...
    def cut(self, *toCut: Shape) -> Compound: ...
    def fuse(self, *toFuse: Shape, glue: bool = ..., tol: Optional[float] = ...) -> Compound: ...
    def intersect(self, *toIntersect: Shape) -> Compound: ...

def sortWiresByBuildOrder(wireList: List[Wire]) -> List[List[Wire]]: ...
def wiresToFaces(wireList: List[Wire]) -> List[Face]: ...
def edgesToWires(edges: Iterable[Edge], tol: float = ...) -> List[Wire]: ...
