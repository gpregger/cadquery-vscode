from .hull import find_hull as find_hull
from .occ_impl.geom import Location as Location, Vector as Vector
from .occ_impl.shapes import Compound as Compound, Edge as Edge, Face as Face, Shape as Shape, Vertex as Vertex, Wire as Wire, edgesToWires as edgesToWires
from .occ_impl.sketch_solver import ConstraintInvariants as ConstraintInvariants, ConstraintKind as ConstraintKind, DOF as DOF, SketchConstraintSolver as SketchConstraintSolver, arc_first as arc_first, arc_last as arc_last, arc_point as arc_point
from .selectors import Selector as Selector, StringSyntaxSelector as StringSyntaxSelector
from .types import Real as Real
from multimethod import multimethod as multimethod
from typing import Any, Callable, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union

Modes: Any
Point = Union[Vector, Tuple[Real, Real]]
T = TypeVar('T', bound='Sketch')
SketchVal = Union[Shape, Location]

class Constraint:
    tags: Tuple[str, ...]
    args: Tuple[Edge, ...]
    kind: ConstraintKind
    param: Any
    def __init__(self, tags: Tuple[str, ...], args: Tuple[Edge, ...], kind: ConstraintKind, param: Any = ...) -> None: ...

class Sketch:
    parent: Any
    locs: List[Location]
    def __init__(self, parent: Any = ..., locs: Iterable[Location] = ...) -> None: ...
    def __iter__(self) -> Iterator[Face]: ...
    def face(self, b: Union[Wire, Iterable[Edge], Compound, T], angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ..., ignore_selection: bool = ...) -> T: ...
    def importDXF(self, filename: str, tol: float = ..., exclude: List[str] = ..., angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def rect(self, w: Real, h: Real, angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def circle(self, r: Real, mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def ellipse(self, a1: Real, a2: Real, angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def trapezoid(self, w: Real, h: Real, a1: Real, a2: Optional[float] = ..., angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def slot(self, w: Real, h: Real, angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def regularPolygon(self, r: Real, n: int, angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def polygon(self, pts: Iterable[Point], angle: Real = ..., mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def rarray(self, xs: Real, ys: Real, nx: int, ny: int) -> T: ...
    def parray(self, r: Real, a1: Real, da: Real, n: int, rotate: bool = ...) -> T: ...
    def distribute(self, n: int, start: Real = ..., stop: Real = ..., rotate: bool = ...) -> T: ...
    def push(self, locs: Iterable[Union[Location, Point]], tag: Optional[str] = ...) -> T: ...
    def each(self, callback: Callable[[Location], Union[Face, 'Sketch', Compound]], mode: Modes = ..., tag: Optional[str] = ..., ignore_selection: bool = ...) -> T: ...
    def hull(self, mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def offset(self, d: Real, mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def fillet(self, d: Real) -> T: ...
    def chamfer(self, d: Real) -> T: ...
    def clean(self) -> T: ...
    def tag(self, tag: str) -> T: ...
    def select(self, *tags: str) -> T: ...
    def faces(self, s: Optional[Union[str, Selector]] = ..., tag: Optional[str] = ...) -> T: ...
    def wires(self, s: Optional[Union[str, Selector]] = ..., tag: Optional[str] = ...) -> T: ...
    def edges(self, s: Optional[Union[str, Selector]] = ..., tag: Optional[str] = ...) -> T: ...
    def vertices(self, s: Optional[Union[str, Selector]] = ..., tag: Optional[str] = ...) -> T: ...
    def reset(self) -> T: ...
    def delete(self) -> T: ...
    def edge(self, val: Edge, tag: Optional[str] = ..., forConstruction: bool = ...) -> T: ...
    def close(self, tag: Optional[str] = ...) -> T: ...
    def assemble(self, mode: Modes = ..., tag: Optional[str] = ...) -> T: ...
    def solve(self) -> T: ...
    def copy(self) -> T: ...
    def moved(self, loc: Location) -> T: ...
    def located(self, loc: Location) -> T: ...
    def finalize(self) -> Any: ...
